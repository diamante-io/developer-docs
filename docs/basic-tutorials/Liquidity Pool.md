# Liquidity Pool

A `Liquidity Pool` in the context of Diamante (or any blockchain network) is a collection of two or more assets (tokens or coins) that are held in a decentralized system. These pools are designed to facilitate efficient token swaps and trading without relying on traditional order books.

In Diamante, liquidity pools are used primarily in decentralized exchanges (DEXs) and other decentralized finance (DeFi) applications to enable users to trade assets without needing to find a matching buyer or seller for every transaction. Instead, users can trade against the liquidity pool, which contains both assets (e.g., DIAM and a custom token). Liquidity pools enable decentralized trading without relying on a central exchange. This allows users to trade assets directly with each other through smart contracts, which automatically adjust the exchange rate based on the liquidity in the pool.<br>
`Pool Reserves`: A liquidity pool consists of two or more assets in predefined quantities. For example, a pool may have 1000 DIAM and 100,000 custom tokens. The amount of each asset in the pool determines the current price of the assets relative to each other. As users swap tokens, the balance of assets in the pool changes, which in turn affects the price.<br>
`Automated Market Maker (AMM)`: Liquidity pools use an Automated Market Maker (AMM) algorithm, which determines the price of assets in the pool based on the proportion of each asset in the pool. For example, if there is more of one asset compared to the other, the price of the asset with the larger quantity will be lower (to balance the pool).<br>
`Liquidity Provider Rewards`: Users who contribute assets to liquidity pools (called liquidity providers) earn a share of the transaction fees generated by swaps that happen within the pool. These rewards are proportional to their contribution to the pool.<br>
`Slippage and Price Impact`: When a large amount of an asset is swapped, the price of the asset in the pool can change due to the imbalance caused by the transaction. This is called slippage, and liquidity pools allow users to set slippage tolerance to manage price changes within acceptable limits.

### How to create Liquidity Pool in Diamante

creating a liquidity pool for trading between two assets using a constant product formula.

1. Create the Liquidity Pool Asset

<!-- tabs:start -->

#### **Javascript**

```js
const lpAsset = new LiquidityPoolAsset(
  Asset.native(), //Native Token
  tokenAsset, //Custom token
  30 // Fee parameter for the pool (0.3%)
);
```

<!-- tabs:end -->

2. Generate the Liquidity Pool ID and Convert the Liquidity Pool ID to a Buffer(Buffers are used in Node.js to handle binary data, and this conversion is likely necessary for including the pool ID in blockchain transactions.)

<!-- tabs:start -->

#### **Javascript**

```js
const liquidityPoolId = getLiquidityPoolId(
  "constant_product",
  lpAsset
).toString("hex");
console.log("Your pool ID:", liquidityPoolId);
const liquidityPoolIdBuffer = Buffer.from(liquidityPoolId, "hex");
```

<!-- tabs:end -->

# Liquidity Pool Deposit

The `Liquidity Pool Deposit` operation is essential for users who wish to provide liquidity to decentralized exchanges or other DeFi applications. By controlling the deposit amount and the price range, liquidity providers can maintain better control over their assets and reduce the risk of unfavorable trades due to slippage. This feature plays a crucial role in ensuring liquidity and price stability within decentralized financial ecosystems.

### Key Characteristics:

- **Purpose**: This operation is used to deposit assets (typically two different types of assets) into a liquidity pool, which increases the reserves of the pool in exchange for liquidity pool shares. These shares represent the userâ€™s proportional ownership of the pool.
- **Risk of Slippage**: The deposit operation allows users to control slippage (the difference between expected and actual asset amounts due to market changes) by defining the maximum and minimum price range at which they are willing to deposit their assets.
- **Assets in the Pool**: The two assets in the liquidity pool are referred to as Asset A and Asset B. These are typically two different types of tokens or coins (e.g., DIAM and a custom token).

### Use Case:

- **Decentralized Exchanges (DEXs)**: Liquidity pools are a fundamental part of decentralized exchanges (DEXs), enabling users to provide liquidity and earn rewards (e.g., transaction fees). By depositing assets into the pool, liquidity providers facilitate token swaps between users.
- **Price Determination**: The ratio of the two assets in the pool affects the price between them, and liquidity providers earn fees proportional to their share of the pool for each trade that occurs within it.
- **Slippage Control**: The ability to set a Min Price and Max Price helps liquidity providers control how their deposited assets are traded relative to each other, avoiding large, unfavorable changes in asset amounts due to market volatility.

### Key Components:

- **Liquidity Pool ID**: A unique identifier for the liquidity pool where the assets are being deposited. This ID ensures that assets are deposited into the correct pool.
- **Max Amount A and Max Amount B**: These parameters specify the maximum amount of each asset (A and B) that the user is willing to deposit into the pool. The actual deposited amount will depend on the pool's current reserves and any slippage settings.
- **Min Price and Max Price**: These parameters define the acceptable price range for the deposit in terms of the ratio between Asset A and Asset B. The price is calculated as the ratio of the amounts deposited (depositA/depositB). Setting a minimum and maximum price ensures that the liquidity provider's assets are not deposited at an undesirable price due to market fluctuations.

<!-- tabs:start -->

#### **Javascript**

```js
const {
  Asset,
  Aurora,
  BASE_FEE,
  Keypair,
  Operation,
  TransactionBuilder,
  LiquidityPoolAsset,
  getLiquidityPoolId,
} = require("diamnet-sdk");

const secret = "SB4EHJXQGD3TDDJJ3MQKL5LZ2JOZSIKTBITFG6VHQ4XPVI42PCBZWBLU";

// Initialize Diamante testnet server
const server = new Aurora.Server("https://diamtestnet.diamcircle.io/");

// Main function to add liquidity to a liquidity pool
async function addLiquidity() {
  // Load the keypair and public key for the account
  const keypair = Keypair.fromSecret(secret);
  const publicKey = keypair.publicKey();

  // Load the account details from the Diamante testnet
  let questAccount = await server.loadAccount(publicKey);

  // Define the token asset (e.g., WOLF token)
  const tokenAsset = new Asset(
    "WOLF",
    "GAUOYFQZUERFKOXKUCE2BBVYLR6C6NG2OBCGA4GU6X67C6OJKLFCHY5E"
  );

  // Display account balances for DIAM (native asset) and WOLF token
  const balances = questAccount.balances;
  balances.forEach(function (balance) {
    if (balance.asset_type === "native") {
      console.log("DIAM Balance:", balance.balance);
    } else if (balance.asset_code === "WOLF") {
      console.log("Token Balance:", balance.balance);
    }
  });

  // Create the liquidity pool asset (constant product type) with DIAM and WOLF token
  const lpAsset = new LiquidityPoolAsset(
    Asset.native(),
    tokenAsset,
    30 // Fee parameter for the pool (0.3%)
  );

  // Generate the liquidity pool ID based on the asset pair and fee
  const liquidityPoolId = getLiquidityPoolId(
    "constant_product",
    lpAsset
  ).toString("hex");
  console.log("Your pool ID:", liquidityPoolId);

  // Convert the liquidity pool ID to a buffer for use in transactions
  const liquidityPoolIdBuffer = Buffer.from(liquidityPoolId, "hex");

  // Step 1: Establish a trustline for the liquidity pool asset
  const trustTransaction = new TransactionBuilder(questAccount, {
    fee: BASE_FEE,
    networkPassphrase: "Diamante Testnet 2024",
  })
    .addOperation(
      Operation.changeTrust({
        asset: lpAsset,
      })
    )
    .setTimeout(30)
    .build();

  // Sign and submit the trustline transaction
  trustTransaction.sign(keypair);
  const trustResult = await server.submitTransaction(trustTransaction);
  console.log("Trust line established successfully:", trustResult.hash);

  // Reload the account to fetch updated information
  questAccount = await server.loadAccount(publicKey);

  // Step 2: Deposit assets into the liquidity pool
  const depositTransaction = new TransactionBuilder(questAccount, {
    fee: BASE_FEE,
    networkPassphrase: "Diamante Testnet 2024",
  })
    .addOperation(
      Operation.liquidityPoolDeposit({
        liquidityPoolId: liquidityPoolIdBuffer, // Liquidity pool ID
        maxAmountA: "10", // Maximum amount of DIAM to deposit
        maxAmountB: "20", // Maximum amount of WOLF token to deposit
        minPrice: { n: 1, d: 2 }, // Minimum price ratio of Token to DIAM (1/2)
        maxPrice: { n: 1, d: 1 }, // Maximum price ratio of Token to DIAM (1/1)
      })
    )
    .setTimeout(30)
    .build();

  // Sign and submit the deposit transaction
  depositTransaction.sign(keypair);
  const depositResult = await server.submitTransaction(depositTransaction);
  console.log("Liquidity provided successfully:", depositResult.hash);
}

// Run the function to add liquidity
addLiquidity();
```

<!-- tabs:end -->

# Liquidity Pool Withdraw

A `Liquidity Pool Withdraw` operation in Diamante refers to the process of withdrawing assets from a liquidity pool. When a liquidity provider (LP) wants to retrieve their assets from the pool, they do so by redeeming their pool shares for the assets that were deposited into the pool. This process decreases the amount of `pool shares` the LP holds and, in return, they receive a proportionate share of the pool's reserves.

### Key Characteristics

1. **Withdraw Assets in Proportion to Pool Shares**: When a liquidity provider withdraws assets, they receive a share of each of the assets in the pool. The amount they receive is proportional to the number of pool shares they have. This helps ensure that the liquidity provider receives an amount equivalent to their contribution in the pool.
2. **Slippage Control**: Just like deposits, withdrawals also come with the potential for slippage. Slippage occurs when the withdrawn amount differs from the expected amount due to price fluctuations in the pool. The minAmountA and minAmountB parameters allow liquidity providers to specify the minimum amount of each asset they expect to receive upon withdrawal, providing a control mechanism to prevent significant slippage.
3. **Reduction in Pool Shares**: When liquidity is withdrawn, the number of pool shares held by the LP decreases. These shares are redeemed in exchange for a proportional amount of assets from the liquidity pool.
4. **Reducing Pool Liquidity**: Withdrawing assets from a pool reduces the total liquidity available for trading within that pool. This may affect the price and trading volume within the pool, depending on the amount of assets withdrawn.
5. **Resulting in Reduced Liquidity Provider Rewards**: As the liquidity provider withdraws their share of assets, they will also receive a reduced share of the transaction fees generated by the pool. This is because their proportional ownership of the pool has decreased.

### Use Cases

1. **Exiting from a Liquidity Pool**: A liquidity provider may wish to exit the liquidity pool by withdrawing their contribution of assets. For example, if an LP provided DIAM and a custom token (ABC) to a pool, they can withdraw the proportion of DIAM and ABC tokens they originally deposited, as well as their share of the fees earned by the pool.
2. **Liquidation of Pool Shares**: In certain cases, liquidity providers may wish to liquidate their pool shares for cashing out the assets they provided. This could be due to a change in market conditions, a need for liquidity, or a strategic decision to exit the pool.
3. **Managing Slippage**: When withdrawing, the LP might want to control the risk of slippage, ensuring that the amount they withdraw doesn't deviate too much from the spot price. By using minAmountA and minAmountB, they can set limits on the minimum amount of each asset they will accept based on the current price.
4. **Portfolio Rebalancing**: A liquidity provider may want to withdraw some assets to rebalance their portfolio. If the price of the assets in the pool has changed significantly, they may choose to withdraw one of the assets in greater proportion to maintain their desired portfolio allocation.

### Key Components

1. **Liquidity Pool ID** (`liquidityPoolID`): The unique identifier for the liquidity pool from which assets are being withdrawn. It ensures that the transaction targets the correct pool.
2. **Amount** (`amount`): The number of pool shares to withdraw. The more shares the liquidity provider has, the more assets they will receive upon withdrawal. The pool shares are redeemed in proportion to the amount specified.
3. **Min Amount A** (`minAmountA`): The minimum amount of the first asset (Asset A) the liquidity provider is willing to withdraw. If the actual withdrawal would result in less than this amount due to slippage, the transaction will fail. This ensures the liquidity provider doesn't receive too little of the first asset.
4. **Min Amount B** (`minAmountB`): The minimum amount of the second asset (Asset B) the liquidity provider is willing to withdraw. Similar to minAmountA, this ensures that the provider doesn't receive less than a minimum acceptable amount of Asset B.

<!-- tabs:start -->

#### **Javascript**

```js
// Import necessary modules from the Diamnet SDK
const {
  Aurora,
  BASE_FEE,
  Keypair,
  Operation,
  TransactionBuilder,
} = require("diamnet-sdk");

// Secret key of the account that will interact with the liquidity pool
const secret = "SB4EHJXQGD3TDDJJ3MQKL5LZ2JOZSIKTBITFG6VHQ4XPVI42PCBZWBLU";

// Connect to the Diamnet testnet server
const server = new Aurora.Server("https://diamtestnet.diamcircle.io/");

/**
 * Function to withdraw assets from a liquidity pool.
 *
 * @param {string} liquidityPoolId - The ID of the liquidity pool to withdraw from.
 * @param {string} amount - The number of liquidity pool shares to withdraw.
 * @param {string} minAmountA - The minimum amount of the first asset to receive.
 * @param {string} minAmountB - The minimum amount of the second asset to receive.
 */
async function liquidityPoolWithdraw(
  liquidityPoolId,
  amount,
  minAmountA,
  minAmountB
) {
  // Load the keypair using the secret key
  const keypair = Keypair.fromSecret(secret);
  const publicKey = keypair.publicKey();

  // Fetch the account details from the server
  let questAccount = await server.loadAccount(publicKey);

  // Convert the liquidity pool ID from a string to a Buffer (required for the transaction)
  const liquidityPoolIdBuffer = Buffer.from(liquidityPoolId, "hex");

  // Create a transaction to withdraw assets from the liquidity pool
  const withdrawTransaction = new TransactionBuilder(questAccount, {
    fee: BASE_FEE, // Set the base fee for the transaction
    networkPassphrase: "Diamante Testnet 2024", // Specify the testnet network
  })
    .addOperation(
      // Add a liquidityPoolWithdraw operation
      Operation.liquidityPoolWithdraw({
        liquidityPoolId: liquidityPoolIdBuffer, // Liquidity pool ID
        amount: amount.toString(), // Number of pool shares to withdraw
        minAmountA: minAmountA.toString(), // Minimum amount of asset A to receive
        minAmountB: minAmountB.toString(), // Minimum amount of asset B to receive
      })
    )
    .setTimeout(30) // Set the transaction timeout to 30 seconds
    .build(); // Build the transaction

  // Sign the transaction with the account's keypair
  withdrawTransaction.sign(keypair);

  try {
    // Submit the transaction to the Diamnet server
    const withdrawResult = await server.submitTransaction(withdrawTransaction);
    console.log("Liquidity withdrawn successfully", withdrawResult.hash);
  } catch (error) {
    // Handle transaction failure and log the error
    console.error("Transaction failed:", error.response.data);
    if (error.response.data.extras && error.response.data.extras.result_codes) {
      console.error("Result Codes:", error.response.data.extras.result_codes);
    }
  }
}

// Call the liquidityPoolWithdraw function to execute the withdrawal
liquidityPoolWithdraw(
  "440027a4a8ce095f9f2c606dde7fd789fd7c2f7e5c1f1f681aef818bef417cac", // Example Pool ID
  "3", // Amount of pool shares to withdraw
  "1", // Minimum amount of the first asset to withdraw
  "1" // Minimum amount of the second asset to withdraw
);
```

<!-- tabs:end -->

The `Liquidity Pool Withdraw` operation in Diamante is a crucial feature that allows liquidity providers to redeem their share of assets from a pool. By withdrawing assets, liquidity providers decrease their share in the pool and may earn transaction fees generated by the poolâ€™s trades. The parameters minAmountA and minAmountB ensure that providers have control over slippage, which helps maintain fairness and reduces the risk of unexpected price fluctuations when withdrawing assets.
